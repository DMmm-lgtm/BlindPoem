---
globs: *.ts,*.tsx
---

# TypeScript 和 React 开发规范

## TypeScript 类型定义

### 核心类型接口

#### 诗句类型
```typescript
// src/lib/supabaseClient.ts
export interface Poem {
  id?: string;
  content: string;          // 诗句内容（必填）
  poem_title?: string;      // 诗名（可选，数据库中可能为空）
  author?: string;          // 作者（可选，数据库中可能为空）
  mood?: string;            // 心情关键词（如：happy, sad）
  created_at?: string;      // 创建时间
}
```

#### Gemini API 返回类型
```typescript
// src/lib/geminiClient.ts
export interface PoemResponse {
  content: string;      // 诗句内容（≤30字）
  poem_title: string;   // 诗名
  author: string;       // 作者
}
```

#### Emoji 心情类型
```typescript
// src/App.tsx
interface EmojiMood {
  emoji: string;    // Emoji 字符（如：😊）
  mood: string;     // 中文心情名（如：快乐）
  keyword: string;  // 英文关键词（如：happy）
}
```

### 类型规范
- ✅ **必须定义接口**: 所有 API 返回值、数据库模型都要有接口
- ✅ **使用明确类型**: 避免使用 `any`，用 `unknown` 或具体类型
- ✅ **可选属性**: 使用 `?` 标记可能为空的字段
- ❌ **避免类型断言**: 除非确实必要，不要使用 `as`

---

## React 组件规范

### 函数组件结构
```typescript
import { useState, useEffect } from 'react';

function App() {
  // 1. 状态定义（使用明确类型）
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [poemData, setPoemData] = useState<{
    content: string;
    poem_title: string;
    author: string;
  } | null>(null);

  // 2. Effect hooks
  useEffect(() => {
    // 副作用逻辑
  }, [依赖项]);

  // 3. 事件处理函数
  const handleEmojiClick = async (keyword: string, mood: string) => {
    // 处理逻辑
  };

  // 4. 渲染
  return (
    <div>
      {/* JSX */}
    </div>
  );
}

export default App;
```

### 组件命名规范
- **组件文件**: PascalCase，如 `App.tsx`
- **工具函数**: camelCase，如 `geminiClient.ts`
- **类型文件**: PascalCase，如 `PoemResponse`

---

## State 管理规范

### 状态设计原则
```typescript
// ✅ 推荐：状态最小化，明确类型
const [poemData, setPoemData] = useState<PoemResponse | null>(null);
const [isLoading, setIsLoading] = useState<boolean>(false);

// ❌ 避免：状态冗余
const [poemContent, setPoemContent] = useState<string>('');
const [poemTitle, setPoemTitle] = useState<string>('');
const [poemAuthor, setPoemAuthor] = useState<string>('');
// 应该合并成一个对象
```

### 异步状态更新
```typescript
const handleEmojiClick = async (keyword: string, mood: string) => {
  setIsLoading(true);
  setPoemData(null); // 清空之前的数据
  
  try {
    const poem = await generatePoem(keyword, mood);
    setPoemData(poem);
    
    // 异步操作不阻塞 UI
    savePoemToDatabase(poem.content, poem.poem_title, poem.author, keyword);
  } catch (error) {
    console.error('❌ 错误：', error);
    // 容错逻辑
  } finally {
    setIsLoading(false); // 确保加载状态重置
  }
};
```

---

## Effect Hooks 使用规范

### 定时器清理
```typescript
// ✅ 推荐：正确清理定时器
useEffect(() => {
  if (poemData) {
    const timer = setTimeout(() => {
      setShowLoveButton(true);
    }, 10000);

    // 清理函数
    return () => clearTimeout(timer);
  }
}, [poemData]);
```

### 依赖项规范
```typescript
// ✅ 推荐：明确列出所有依赖
useEffect(() => {
  fetchData(userId, filter);
}, [userId, filter]);

// ❌ 避免：空依赖数组但使用了外部变量
useEffect(() => {
  fetchData(userId); // userId 应该在依赖数组中
}, []);

// ✅ 如果确实只想运行一次，确保不依赖外部状态
useEffect(() => {
  console.log('组件挂载');
}, []);
```

---

## 错误处理规范

### API 调用错误处理
```typescript
// ✅ 推荐：完整的错误处理
try {
  const poem = await generatePoem(keyword, mood);
  setPoemData(poem);
} catch (error) {
  console.error('❌ AI 调用失败：', error);
  
  // 容错机制
  const fallbackPoem = await getRandomPoemFromDatabase();
  
  if (fallbackPoem) {
    setPoemData(fallbackPoem);
    console.log('✅ 使用数据库备用诗句');
  } else {
    // 最终失败提示
    alert('获取诗句失败，且数据库中暂无备用诗句。');
  }
} finally {
  setIsLoading(false);
}
```

### 环境变量检查
```typescript
// ✅ 推荐：启动时检查环境变量
const apiKey = import.meta.env.VITE_GEMINI_API_KEY;

if (!apiKey) {
  throw new Error('缺少 Gemini API Key！请检查 .env.local 文件');
}
```

---

## 性能优化

### 避免不必要的重渲染
```typescript
// ✅ 推荐：使用 React.memo 包裹纯组件
import { memo } from 'react';

const EmojiButton = memo(({ emoji, onClick }: Props) => {
  return <button onClick={onClick}>{emoji}</button>;
});

// ✅ 推荐：使用 useCallback 缓存函数
const handleClick = useCallback((keyword: string) => {
  console.log(keyword);
}, []);
```

### 异步操作不阻塞 UI
```typescript
// ✅ 推荐：数据库写入异步执行
setPoemData(poem);

// 不使用 await，不阻塞 UI
savePoemToDatabase(poem.content, poem.poem_title, poem.author, keyword);
```

---

## 代码风格

### 命名规范
```typescript
// 组件：PascalCase
function PoemDisplay() {}

// 函数：camelCase
function generatePoem() {}

// 常量：UPPER_SNAKE_CASE
const MAX_POEM_LENGTH = 30;

// 类型：PascalCase
interface PoemResponse {}
```

### 注释规范
```typescript
/**
 * 根据心情关键词生成诗句
 * @param keyword 心情关键词（如：happy, sad）
 * @param moodName 心情名称（如：快乐、悲伤）
 * @returns 诗句数据（content, poem_title, author）
 */
export async function generatePoem(
  keyword: string,
  moodName: string
): Promise<PoemResponse> {
  // 实现
}
```

### Import 顺序
```typescript
// 1. React 和第三方库
import { useState, useEffect } from 'react';
import { GoogleGenerativeAI } from '@google/generative-ai';

// 2. 本地模块
import { supabase, Poem } from './lib/supabaseClient';
import { generatePoem } from './lib/geminiClient';

// 3. 样式文件
import './App.css';
```

---

## 最佳实践

### ✅ 推荐做法
- 使用 TypeScript 严格模式（`"strict": true`）
- 所有异步函数必须有错误处理
- 组件保持简洁，复杂逻辑提取到 `lib/` 目录
- 使用 `console.log` 时添加 emoji 前缀（✅ ❌ ⚠️）
- 环境变量使用 `import.meta.env.VITE_*` 访问

### ❌ 避免做法
- 不要使用 `any` 类型
- 不要在组件中直接写复杂的业务逻辑
- 不要忽略 ESLint 警告
- 不要在 useEffect 中忘记清理副作用
- 不要硬编码 API Key 或敏感信息

### 调试技巧
```typescript
// 使用带类型的 console.log
console.log('✅ 诗句数据：', poem satisfies PoemResponse);

// 使用断点调试
debugger;

// 类型检查
const poem: PoemResponse = await generatePoem(keyword, mood);
```
